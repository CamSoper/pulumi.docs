{{ with $.Params.api_url }}
    {{ $openapi := dict }}
    {{ $resource := resources.GetRemote . (dict "type" "application/json") }}
    {{ if $resource }}
        {{ $openapi = $resource | transform.Unmarshal }}
        <!-- Debug output -->
        <div style="display: flex; flex-direction: column; align-items: stretch;" data-openapi-content="true">
            {{ $taggedEndpoints := dict }}
            {{ $untaggedEndpoints := slice }}
            {{ $filterTag := $.Params.filter_tag }}
            
            <!-- First collect all unique tags that match our criteria -->
            {{ $allTags := slice }}
            {{ range $path, $pathMethods := $openapi.paths }}
                {{ range $pathMethod, $pathDetails := $pathMethods }}
                    {{ if $pathDetails.tags }}
                        {{ range $tag := $pathDetails.tags }}
                            <!-- Get all tags by provided tag name or prefixed by provided tag name -->
                            {{ if $filterTag }}
                                {{ if or (eq $tag $filterTag) (hasPrefix $tag (printf "%s: " $filterTag)) }}
                                    {{ $allTags = $allTags | append $tag }}
                                {{ end }}
                            {{ end }}
                        {{ end }}
                    {{ end }}
                {{ end }}
            {{ end }}
            
            <!-- If no tags found and no filter tag specified, create default "Other Endpoints" tag -->
            {{ if and (not $filterTag) (eq (len $allTags) 0) }}
                {{ $allTags = $allTags | append "Other Endpoints" }}
            {{ end }}
            
            <!-- Initialize empty slices for each tag -->
            {{ range $tag := uniq $allTags }}
                {{ $taggedEndpoints = merge $taggedEndpoints (dict $tag (slice)) }}
            {{ end }}
            
            <!-- Group endpoints by tags -->
            {{ range $path, $pathMethods := $openapi.paths }}
                {{ range $pathMethod, $pathDetails := $pathMethods }}
                    {{ $endpoint := dict "path" $path "method" $pathMethod "details" $pathDetails }}
                    <!-- If we have a filter tag, only include endpoints that match the filter tag -->
                    {{ if $filterTag }}
                        {{ if $pathDetails.tags }}
                            {{ range $tag := $pathDetails.tags }}
                                {{ if or (eq $tag $filterTag) (hasPrefix $tag (printf "%s: " $filterTag)) }}
                                    {{ $currentSlice := index $taggedEndpoints $tag }}
                                    {{ $taggedEndpoints = merge $taggedEndpoints (dict $tag ($currentSlice | append $endpoint)) }}
                                {{ end }}
                            {{ end }}
                        {{ end }}
                    <!-- If we don't have a filter tag, include untagged endpoints -->
                    {{ else }}
                        {{ if $pathDetails.tags }}
                            {{ range $tag := $pathDetails.tags }}
                                {{ $currentSlice := index $taggedEndpoints $tag }}
                                {{ $taggedEndpoints = merge $taggedEndpoints (dict $tag ($currentSlice | append $endpoint)) }}
                            {{ end }}
                        {{ else if eq (len $allTags) 1 }}
                            {{ $currentSlice := index $taggedEndpoints "Other Endpoints" }}
                            {{ $taggedEndpoints = merge $taggedEndpoints (dict "Other Endpoints" ($currentSlice | append $endpoint)) }}
                        {{ end }}
                    {{ end }}
                {{ end }}
            {{ end }}

            {{ if $filterTag }}
                {{ $filteredEndpoints := dict }}
                {{ $subsections := dict }}
                
                {{ range $tag, $endpoints := $taggedEndpoints }}
                    {{ if hasPrefix $tag (printf "%s: " $filterTag) }}
                        {{ $subsection := replace $tag (printf "%s: " $filterTag) "" 1 }}
                        {{ $currentSlice := index $subsections $subsection | default (slice) }}
                        {{ $subsections = merge $subsections (dict $subsection ($currentSlice | append $endpoints)) }}
                    {{ else if eq $tag $filterTag }}
                        {{ $filteredEndpoints = merge $filteredEndpoints (dict $tag $endpoints) }}
                    {{ end }}
                {{ end }}
                
                {{ template "openapi/filtered-endpoint-group.html" (dict "filteredEndpoints" $filteredEndpoints "subsections" $subsections "openapi" $openapi) }}
            {{ else }}
                {{ template "openapi/endpoint-group.html" (dict "untaggedEndpoints" $untaggedEndpoints "openapi" $openapi) }}
            {{ end }}
        </div>
        
        <!-- Add script to regenerate table of contents after OpenAPI is loaded -->
        <script>
            // Wait for the document to be fully loaded
            document.addEventListener("DOMContentLoaded", function() {
                // Make sure the generateOnThisPage function is available
                if (typeof window.generateOnThisPage === "function") {
                    // Re-generate the table of contents
                    window.generateOnThisPage();
                } else {
                    console.error("generateOnThisPage function not found");
                }
            });
        </script>
    {{ end }}
{{ end }} 